#!/usr/bin/python2.4

# Copyright (C) 2007 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Validates a Google Transit Feed Specification feed.
#
# Usage:
# feed_validator.py [--noprompt] <feed zip file or directory>

import codecs
import optparse
import os.path
import time
import transitfeed
import sys
import webbrowser

DEFAULT_UNUSED_LIMIT = 5  # number of unused stops to print

def ProblemCountText(problem_count):
  if (problem_count == 1):
    return 'one issue'
  else:
    return '%d issues' % problem_count

class HTMLCountingProblemReporter(transitfeed.ProblemReporter):
  def __init__(self):
    transitfeed.ProblemReporter.__init__(self)
    self._output = []
    self._context = None
    self.count = 0
    self.unused_stops = []  # [(stop_id, stop_name)...]

  def SetFileContext(self, filename, row_num, row, row_headers):
    """Save the current context to be output with any errors.

    Args:
      filename: string
      row_num: int
      row: list of unicode strings
      row_headers: list of column headers, its order corresponding to row's
    """
    self._context = (row_num, filename, map(unicode, row), row_headers)

  def UnusedStop(self, stop_id, stop_name):
    self.count += 1
    self.unused_stops.append((stop_id, stop_name))
    
  def _Report(self, problem_text):
    self.count += 1
    problem_text = problem_text.replace('\n', '<br>')
    self._output.append('<li>')
    self._output.append('<div class="problem">%s</div>' %
                        self._EncodeUnicode(problem_text))
    if self._context:
      self._output.append('in line %d of <code>%s</code><br>' %
                           self._context[:2])
      self._output.append('<table><tr>')
      for cell in self._context[3]:
        self._output.append('<th>%s</th>' % cell)
      self._output.append('</tr><tr>')
      for cell in self._context[2]:
        self._output.append('<td>%s</td>' %
                            self._EncodeUnicode(cell))
      self._output.append('</tr></table>')
    self._output.append('</li><br>\n')
    
  def _UnusedStopSection(self):
    unused = []
    unused_count = len(self.unused_stops)
    if unused_count:
      if unused_count == 1:
        unused.append('%d.<br>' % self.count)
        unused.append('<div class="unused">')
        unused.append('one stop was found that wasn\'t')
      else:
        unused.append('%d&ndash;%d.<br>' %
                      (self.count - unused_count + 1, self.count))
        unused.append('<div class="unused">')
        unused.append('%d stops were found that weren\'t' % unused_count)
      unused.append(' used in any trips')
      if unused_count > DEFAULT_UNUSED_LIMIT:
        self.unused_stops = self.unused_stops[:DEFAULT_UNUSED_LIMIT]
        unused.append(' (the first %d are shown below)' %
                      len(self.unused_stops))
      unused.append(':<br>')
      unused.append('<table><tr><th>stop_name</th><th>stop_id</th></tr>')
      for stop_id, stop_name in self.unused_stops:
        unused.append('<tr><td>%s</td><td>%s</td></tr>' % (stop_name, stop_id))
      unused.append('</table><br>')
      unused.append('</div>')
    return ''.join(unused)
    
  def GetOutput(self, feed_location):
    if problems.count:
      summary = ('<span class="fail">%s found</span' %
                 ProblemCountText(problems.count))
    else:
      summary = '<span class="pass">feed validated successfully</span>'
      
    basename = os.path.basename(feed_location)
    feed_path = (feed_location[:feed_location.rfind(basename)], basename)
    
    output_contents = """
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/> 
<title>FeedValidator: %s</title>
<style>
body {font-family: Georgia, serif}
.path {color: gray}
div.problem {max-width: 500px}
td,th {background-color: khaki; padding: 2px; font-family:monospace}
table {border-spacing: 5px 0px; margin-top: 3px}
span.pass {background-color: lightgreen}
span.fail {background-color: yellow}
.pass, .fail {font-size: 16pt; padding: 3px}
ol,.unused {padding-left: 40pt}
.footer {font-size: 10pt}
</style>
</head>
<body>
Validation results for feed:<br>
<code><span class="path">%s</span><b>%s</b></code><br><br>
%s
<ol>%s</ol>
%s
<div class="footer">
Generated by <a href="http://code.google.com/p/googletransitdatafeed/wiki/FeedValidator">
FeedValidator</a> version %s on %s.
</div>
</body>
</html>""" % (feed_path[1], feed_path[0], feed_path[1],
              summary, ''.join(self._output),
              self._UnusedStopSection(),
              transitfeed.__version__, time.asctime())
    return output_contents

if __name__ == '__main__':
  parser = optparse.OptionParser()
  parser.add_option('-n', '--noprompt', action='store_false',
                    dest='manual_entry')
  parser.set_defaults(manual_entry=True)
  (options, args) = parser.parse_args()
  manual_entry = options.manual_entry
  if not len(args) == 1:
    if manual_entry:
      feed = raw_input('Enter Feed Location: ')
    else:
      print 'Usage: feedvalidator [--noprompt] <feed_name>'
      sys.exit(1)
  else:
    feed = args[0]

  feed = feed.strip('"')
  print 'validating %s' % feed
  problems = HTMLCountingProblemReporter()
  loader = transitfeed.Loader(feed, problems=problems, extra_validation=True)
  loader.Load()
  
  exit_code = 0
  if problems.count:
    print 'ERROR: %s found' % ProblemCountText(problems.count)
    exit_code = 1
  else:
    print 'feed validated successfully'
    
  output_filename = 'validation-results.html'
  output_file = open(output_filename, 'w')
  output_file.write(problems.GetOutput(os.path.abspath(feed)))
  output_file.close()
  webbrowser.open('file://%s' % os.path.abspath(output_filename))
    
  sys.exit(exit_code)
